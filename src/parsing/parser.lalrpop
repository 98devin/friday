
use crate::parsing::ast::{*};
use std::str::FromStr;
use std::iter;

grammar;

Float        = r"[0-9](_?[0-9]+)*(.[0-9](_?[0-9]+)*)?";
AlphaWord    = r"[a-zA-Z][a-zA-Z0-9_']*";
SymbolWord   = r"[~!@#$%^&*+=<>,:?`|;\[\]{}-]+";
Empty        = r"_+([a-zA-Z][a-zA-Z0-9_]*)?";

String : String = <s : r#""([^"]|\\")*""#> => String::from(&s[1..s.len()-1]);

NonemptyList<T> : Vec<T> = <T+>;

Parenthesized<T> = "(" <T> ")";

NonemptyListSep<T, Sep> : Vec<T> =
    <mut ts: (<T> Sep)*> <tf: T> => { ts.push(tf); ts };

Number : f64 = <Float> => f64::from_str(<>).unwrap();

AlphaIdentifier : Ident = <AlphaWord> => Ident(String::from(<>));
SymbolIdentifier : Ident = <SymbolWord> => Ident(String::from(<>));

Identifier : Ident = {
    <AlphaIdentifier>,
    <SymbolIdentifier>,
};

Atom<T> : Atom<T> = {
    <Empty> => Atom::Hole,
    <Number> => Atom::Number(<>),
    <Identifier> => Atom::Ident(<>),
    <String> => Atom::String(<>),
    "(" ")"  => Atom::Unit,
    <Parenthesized<T>> => Atom::Nested(Box::new(<>)),
};

MatchClause : (Patn, Expr) =
    "|" <p : Patn> "=" <e : Expr> => (p, e);

Decl : Decl = {
    "let" <p : Patn> "=" <e : Expr> => Decl::Let(Box::new(p), Box::new(e)),
    "def" <s : Signature> "=" <e : Expr> => Decl::Def(s, Box::new(e)),
    "con" <s : SignatureC> => Decl::Con(s),
    "mod" <n : Identifier> "=" <m : Modl> => Decl::Mod(n, Box::new(m)),
    "use" <m : Modl> => Decl::Use(Box::new(m))
};

ModlPath : ModlPath =
    <dot : "."?>
    <path : NonemptyListSep<AlphaIdentifier,".">>
    =>
    ModlPath {
        path, absolute: dot.is_some()
    };

Modl : Modl = {
    "mod" <d : Decl*> "end" => Modl::ModExp(d),
    <p : ModlPath> => Modl::Named(p),
}

Signature : Vec<Sign> = <Signature1>;

Signature1 : Vec<Sign> =
    <patn : Parenthesized<Patn>?> <sig : Signature2> =>
        patn.map(|p| Sign::Patn(Box::new(p)))
            .into_iter()
            .chain(sig)
            .collect();

Signature2 : Vec<Sign> =
    <w : Identifier> <patn : Parenthesized<Patn>?> <sig : Signature2?> =>
        {
            let patn = patn.map(|p| Sign::Patn(Box::new(p)));
            iter::once(Sign::Word(w))
                .chain(patn)
                .chain(sig.into_iter().flatten())
                .collect()
        };

SignatureC : Vec<Sign> = <Signature1C>;

EmptyPattern : Patn = <Empty> => Patn::Flat(vec![Atom::Hole]);

Signature1C : Vec<Sign> =
    <patn : EmptyPattern?> <sig : SignatureC2> =>
        patn.map(|p| Sign::Patn(Box::new(p)))
            .into_iter()
            .chain(sig)
            .collect();

SignatureC2 : Vec<Sign> =
    <w : Identifier> <patn : EmptyPattern?> <sig : SignatureC2?> =>
        {
            let patn = patn.map(|p| Sign::Patn(Box::new(p)));
            iter::once(Sign::Word(w))
                .chain(patn)
                .chain(sig.into_iter().flatten())
                .collect()
        };

Expr : Expr = {
    "fun" <p : Patn> "=" <e : Expr> => Expr::Func(Box::new(p), Box::new(e)),
    "match" <e : Expr> <cls : MatchClause+> "end" => Expr::Match(Box::new(e), cls),
    <decls : Decl+> "in" <e : Expr> => Expr::Scoped(decls, Box::new(e)),
    <Atom<Expr>+> => Expr::Flat(<>),
};

Patn : Patn = {
    <decls : Decl+> "in" <p : Patn> => Patn::Scoped(decls, Box::new(p)),
    <Atom<Patn>+> => Patn::Flat(<>),
}

pub Sequence : Vec<Decl> = <Decl*>;